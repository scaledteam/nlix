# Руководство по написанию программ для операционной системы nlix.
# 26.02.2018

Содержание:
1. Создание файла программы.
2. Работа с памятью программы.
3. Система потоков nlix.
4. Создание программы для терминала.
5. Использование реальных устройств.
6. Перенаправления потоков.
7. Запуск программы с параметрами.

1. Создание файла программы.
Nlix обычно хранит исполняемые коды программ в директории nlix/bin/. Файл с кодом программы желательно поместить в nlix/bin/ и прописать в коде ядра:

case "my-program",          #include "nlix/bin/my-program" break

Имя, указанное возле case, будет именем программы. Оно не обязательно должно совпадать с именем файла.

2. Работа с памятью программы.
Nlix предоставляет каждой программе память. Она хранится в таблице Ps. Если мы хотим получить доступ к памяти программы, мы можем обратиться к нему с помощью Ps[ProgramId, table]. Для удобства ядро предоставляет возможность обращаться к переменной P, которая содержит память текущей программы. Для примера напишем программу, которое имеет 2 стадии выполнения:

switch (P["state", number]) {
	case 0,
		print("state " + P["state", number])
		P["state", number] = 1
		break
	
	case 1,
		print("state " + P["state", number])
		end()
		break
}

Программа выведет в чат "state 0", а через тик уже "state 1" и завершит выполнение после комманды end(). Функция end() очищает память программы и указывает ядру, что выполнение кода этой программы стоит прекратить.
Также в таблице P можно указывать любые переменные любых типов кроме "type". Эта переменная зарезервирована для хранения названия программы.

3. Система потоков nlix.
Большинство программ для nlix имеют входной и выходной поток. На момент написания руководства только hotplugd не имеет входных и выходных потоков.
При запуске программы с помощью коммандного интерпретатора sh, коммандный интерпретатор указывает в качестве выходного потока программы драйвер терминала term, а в качестве входного - skbd, название которого расшифровывается как simple keyboard.
skbd позволяет набирать текст на клавиатуре и отправлять во входной поток запущенной программы после нажатия клавиши enter. Таким образом, набрав на клавиатуре "test" и нажав клавишу enter, skbd передаст во входной поток запущенной программы фразу "test".
Драйвер терминала подключен к выходному потоку. Если запущенная программа передаёт в выходной поток фразу "test\n123", то на экране мы видим фразы "test" и на следующей строке "123".

4. Создание программы для терминала.
Для создания программы для терминала удобно использовать libio и его базовые функции, такие как:

number wait()
string in()
out(string)

Функция wait() возвращает 1 когда программа получает какие-либо данные в свой входной поток.
Функция in() позволяет их получить, но только в том случае, если во входном потоке находятся данные типа string.
Функция out(string) позволяет вывести в выходной поток данные типа string.

Таким образом, можно написать простенькую программу, которая будет выводить нам введённый нами текст:

if (wait()) {
	out("Your input is " + in() + "\n")
	end()
}

5. Использование реальных устройств.
Библиотека libdevices предоставляет нам функцию deviceGet(DeviceType:string) для работы с устройствами, подключаемыми через порты. Для получения устройства удобно использовать конструкцию вида:

switch (P["state", number]) {
	case 0,
		if (deviceGet("type_of_device")) {
			# Код для инициализации устройства
	
			P["state", number] = 1
		}
		break
	
	case 1,
		# Код для работы с устройством
		break
}

Где type_of_device - это тип устройства, которое вы жалаете получить.
Функция позволяет получить только один девайс такого типа. При закрытии приложения hotplugd сам возвращает устроство в таблицу с устройствами.
После выполнения указанной конструкции, а также внутри скобок условия можно найти полученное устройство в таблице P["device", wirelink].

6. Перенаправления потоков.
Операционная система nlix позволяет нам запустить приложение и считать его вывод. Для этого можно воспользоваться функцией exec(ProgramName:string), не забыв перенаправить вывод программы в удобный нам поток. Для примера перенаправим вывод ls во входной поток нашей программы:

switch (P["state", number]) {
	case 0,
		local Program = exec("ls")
		P["in", array] = Program["out", array] = array()
		
		P["state", number] = 1
		break
	
	case 1,
		if (wait()) {
			out("Output of \"ls\":\n" + in())
			end()
		}
		break
}

Функция exec(string) возвращает таблицу с памятью программы и указывает ядру приступить к её выполнению. Программа выполнится через несколько тиков, поэтому мы можем подготовить входные потоки к её запуску.
Конструкция

P["in", array] = Program["out", array] = array()

создаёт новый выходной поток для программы "ls", который становится входом для нашей программы. После перехода к следующему состоянию наша программа будет ожидать данные с входного потока и выведет их в выходной поток (если программа запущена в терминале, то в терминал) как только они станут доступны, после чего завершит выполнение.

7. Запуск программы с параметрами.
В прошлом примере мы запустили программу ls и вывели её вывод в терминал. Но ls при отсутствии аргументов выводит только содержимое корневого каталога "/". Чтобы вывести какой-нибудь другой каталог, например, "/devices/", нам потребуется указать это при запуске ls.
Каждую программу можно запустить с аргументами. В коммандном интерпретаторе sh это делается так:

wget http://example.com/ website.html

где "wget" - имя программы, "http://example.com/" - первый аргумент, "website.html" - второй аргумент.
Полученные аргументы хранятся в масссиве P["args", array], где их можно обработать любым удобным вам способом.
Переделаем нашу программу с учётом изменений:

switch (P["state", number]) {
	case 0,
		local Program = exec("ls")
		P["in", array] = Program["out", array] = array()
		P["arg", array] = array("/devices/")
		
		P["state", number] = 1
		break
	
	case 1,
		if (wait()) {
			out("Output of \"ls\":\n" + in())
			end()
		}
		break
}

Как можно заметить, основные принципы остались те же, разве что теперь мы задаём аргументы с помощью конструкции:

P["arg", array] = array("/devices/")
