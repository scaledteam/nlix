#
# Created by scaled
#

@name eclicker

switch (P["state", number]) {
    case 0,
        if (egpReady()) {
            if (egpMax() >= 7) {
                # Graphics
                local Res = egpResolution()
                local TextSize = Res[2] / 15
                
                # Background
                egpBox(1, vec2(), Res)
                egpColor(1, vec())
                
                egpBox(2, vec2(), Res * vec2(1 / 3, 1 / 5))
                
                egpText(3, "0", vec2(), Res * vec2(1 / 3, 1 / 5))
                egpSize(3, TextSize)
                egpColor(3, vec())
                egpAlign(3, 1, 1)
                
                egpBox(4, Res * vec2(1 / 3, 0), Res * vec2(2 / 3, 1))
                egpColor(4, vec(80))
                
                P["ballSize", number] = Res[2] / 6
                egpCircle(5, Res * vec2(1 / 6, 6 / 10), vec2(P["ballSize", number]))
                
                local H = 5
                if (egpMax() >= 17) {
                    local Offset = Res[2] / 30
                    local Pos = Res * vec2(1 / 3, 0) + vec2(Offset)
                    local Step = Res * vec2(1 / 3, 1 / 5)
                    local Size = Res * vec2(1 / 3, 2 / 15) - vec2(Offset * 2, 0)
                    
                    for (X = 0, 1) {
                        for (Y = 0, 4) {
                            H++
                            egpBox(H, Pos + vec2(X, Y) * Step, Size)
                            egpColor(H, vec(63, 127, 255))
                        }
                    }
                }
                
                local Text = 
                    "First\n50\t+1" + "\n\n" + 
                    "Third\n2000\t+30"
                
                H++
                egpText(H, Text, Res * vec2(1 / 3, 0) + vec2(0, TextSize / 2), Res * vec2(1 / 3, 1))
                egpSize(H, TextSize)
                egpAlign(H, 1)
                
                Text = 
                    "Second\n500\t+7" + "\n\n" + 
                    "Last\n6000\t+80"
                
                H++
                egpText(H, Text, Res * vec2(2 / 3, 0) + vec2(0, TextSize / 2), Res * vec2(1 / 3, 1))
                egpSize(H, TextSize)
                egpAlign(H, 1)
                
                # Algorithm
                P["systimeOld", number] = systime()
                
                P["costs", array] = array(
                    50, 500,
                    2000, 6000
                )
                
                P["boosts", array] = array(
                    1, 7,
                    30, 80
                )
                
                P["state", number] = 1
            }
            else {
                end()
            }
        }
        break
    
    case 1,
        if (egpWait()) {
            local DeltaTime = systime() - P["systimeOld", number]
            P["systimeOld", number] = systime()
            
            P["score", number] = P["score", number] + P["speed", number] * DeltaTime
            
            P["circlePos", number] = P["circlePos", number] + (DeltaTime * P["speed", number]) ^ 0.5
            
            if (P["impulse", number] > 0) {
                P["impulse", number] = clamp(P["impulse", number] - 2 * DeltaTime, 0, 1)
            }
            
            egpText(3, int(P["score", number]):toString())
            egpColor(5, hsv2rgb((systime() * 18) % 360, 1, 1))
            
            egpSize(5, vec2(P["ballSize", number] * min(1, (sin(P["circlePos", number]) + 3 + P["impulse", number]) / 4)))
            
            if (egpUse() != P["egpUseOld", number]) {
                P["egpUseOld", number] = egpUse()
                
                if (egpUse()) {
                    local Res = egpResolution()
                    
                    if (inrange(egpCursor(), Res * vec2(1 / 3, 0), Res)) {
                        local Pos = int(egpCursor()[1] / Res[1] * 3) + int(egpCursor()[2] / Res[2] * 5) * 2
                        
                        if (P["score", number] >= P["costs", array][Pos, number]) {
                            P["score", number] = P["score", number] - P["costs", array][Pos, number]
                            P["speed", number] = P["speed", number] + P["boosts", array][Pos, number]
                        }
                    }
                    
                    elseif (inrange(egpCursor(), vec2(Res[1] / 5, 0), Res * vec2(1 / 3, 1))) {
                        P["score", number] = P["score", number] + 1
                        
                        P["impulse", number] = 1
                    }
                }
            }
        }
        break
}
