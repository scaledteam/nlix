#
# Created by scaled
#

@name nlix

@persist [P2F Ps P]:table KPerf KState PName:string

if (!tickClk()) {
    if (clk()) {
        while (perf(KPerf)) {
            KState++
            switch (KState) {
                # Libraries
                case 1, #include "nlix/lib/libobject" break
                case 2, #include "nlix/lib/libkernel" break
                case 3, #include "nlix/lib/libio" break
                case 4, #include "nlix/lib/liboverload" break
                case 5, #include "nlix/init/system-memory" break
                
                # Binaries
                case 10, #include "nlix/lib/libdevices" break
                case 11, #include "nlix/bin/hotplugd" break
                
                # Terminal
                case 21, #include "nlix/bin/term" break
                case 22, #include "nlix/bin/skbd" break
                case 23, #include "nlix/bin/sh" break
                
                case 24, #include "nlix/bin/echo" break
                
                case 25, #include "nlix/bin/plist" break
                case 26, #include "nlix/bin/dlist" break
                case 27, #include "nlix/bin/binlist" break
                
                case 28, #include "nlix/bin/perf" break
                case 29, #include "nlix/bin/overload" break
                case 30, #include "nlix/bin/uptime" break
                
                case 32, #include "nlix/bin/rund" break
                case 33, #include "nlix/bin/kill" break
                case 34, #include "nlix/bin/reboot" break
                case 35, #include "nlix/bin/poweroff" break
                
                case 36, #include "nlix/bin/print-pi" break
                
                # Files
                case 40, #include "nlix/lib/libfs" break
                case 41, #include "nlix/init/fstab" break
                case 42, #include "nlix/bin/fstable" break
                case 43, #include "nlix/bin/fsreal" break
                
                case 44, #include "nlix/bin/ls" break
                case 45, #include "nlix/bin/cat" break
                case 46, #include "nlix/bin/touch" break
                case 47, #include "nlix/bin/rm" break
                
                case 48, #include "nlix/bin/cp" break
                case 49, #include "nlix/bin/wget" break
                
                # Other
                case 50, #include "nlix/bin/bc" break
                case 51, #include "nlix/bin/surl" break
                case 52, #include "nlix/bin/digi-scan" break
                
                # X
                case 59, #include "nlix/bin/kbd" break
                case 60, #include "nlix/lib/libx" break
                case 61, #include "nlix/bin/xworker" break
                case 62, #include "nlix/bin/xstart" break
                case 63, #include "nlix/bin/xclock" break
                case 64, #include "nlix/bin/xres" break
                case 65, #include "nlix/bin/xtiles" break
                case 66, #include "nlix/bin/xeyes" break
                case 67, #include "nlix/bin/xclicker" break
                case 68, #include "nlix/bin/xterm" break
                
                # Init
                #case 70, SYSTEM_NAME = "system0" #include "nlix/init/sync" break
                case 71, #include "nlix/init/autostart" break
                
                # End
                case 73, KState = 1 runOnTick(1) exit() break
                default,
            }
        }
        
        interval(0)
    }
    elseif (first()) {
        KPerf = 5
        
        interval(0)
    }
}  
else {
    while (perf(KPerf)) {
        # Counter
        if (KState >= Ps:count()) {
            KState = 1
        }
        else {
            KState++
        }
        
        # Program memory
        P = Ps[KState, table]
        
        # Clear if parent killed
        if (P:exists("parent") & P["parent", table]:count() == 0) {
            end()
            continue
        }
        
        # Program name
        PName = P["name", string]
        
        # If exist binary (function)
        if (P2F:exists(PName)) {
            P2F[PName, string]()
        }
        elseif (P:count() == 0) {
            # If all programs killed
            if (Ps:count() == 0) {
                runOnTick(0)
                break
            }
            # If program is not valid
            else {
                end()
            }
        }
        # If wrong name
        else {
            out("Program \"" + PName + "\" is not exist.\n")
            end()
        }
    }
}
