#
# Created by scaled
#

@name libx

function xdraw(Object:table) {
    local Type = Object["type", string]
    local Id = Object["id", number]
    local Device = P["device", wirelink]
    
    switch (Type) {
        case "box",
            Device:egpBox(Id, Object["pos", vector2], Object["size", vector2])
            break
        
        case "circle",
            Device:egpCircle(Id, Object["pos", vector2], Object["size", vector2])
            break
        
        case "line",
            Device:egpLine(Id, Object["pos", vector2], Object["size", vector2])
            break
        
        case "text",
            if (Object:exists("size")) {
                Device:egpTextLayout(Id, Object["text", string], Object["pos", vector2], Object["size", vector2])
            }
            else {
                Device:egpText(Id, Object["text", string], Object["pos", vector2])
            }
            Device:egpAlign(Id, Object["align", vector2][1], Object["align", vector2][2])
            if (!Object:exists("sizeNum")) {
                Object["sizeNum", number] = 20
            }
            Device:egpSize(Id, Object["sizeNum", number] * Object["parent", table]["textMultiplier", number])
            Device:egpFont(Id, "Courier New")
            break
        
        case "poly",
            Device:egpPoly(Id, Object["poses", array])
            break
        
        case "frame",
            Device:egpBox(Id, Object["pos", vector2], vec2())
            break
        
        case "",
            Device:egpLine(Id, vec2(), vec2())
            break
        
        default,
            out("Error: unknown type \"" + Type + "\".")
            
            Object["type", string] = ""
            Object["color", vector] = vec(255)
            
            Device:egpLine(Id, vec2(), vec2())
    }
    
    if (!Object["parent", table]:exists("parentFor")) {
        Object["parent", table]["parentFor", table] = table(Object)
    }
    else {
        Object["parent", table]["parentFor", table]:pushTable(Object)
    }
    Device:egpParent(Id, Object["parent", table]["id", number])
    Device:egpColor(Id, Object["color", vector])
}

function table xcreate(Input:table) {
    local Frame = P["xframe", table]
    local Id = Frame["lastId", number] + 1
    Frame["lastId", number] = Id
    
    if (Frame["objects", table]:exists(Id)) {
        local Object = Frame["objects", table][Id, table]
        Object["type", string] = Input["type", string]
        if (Input:exists("pos")) { Object["pos", vector2] = Input["pos", vector2] }
        if (Input:exists("size")) { Object["size", vector2] = Input["size", vector2] }
        if (Input:exists("poses")) { Object["poses", array] = Input["poses", array] }
        if (Input:exists("text")) { Object["text", string] = Input["text", string] }
        if (Input:exists("align")) { Object["align", vector2] = Input["align", vector2] }
        if (Input:exists("sizeNum")) { Object["sizeNum", number] = Input["sizeNum", number] }
        
        if (Input:exists("color")) { Object["color", vector] = Input["color", vector] }
        if (Input:exists("parent")) { Object["parent", table] = Input["parent", table] }
        
        Input:clear()
        xdraw(Object)
        
        return Object
    }
    else {
        # FIX IT
        return NULL
    }
}

function vector2 xcursor() {
    local Frame = P["xframe", table]
    local Device = P["device", wirelink]
    
    if (!Frame:exists("parent")) {
        if (systime() > Frame["cursorTimer", number]) {
            #ifdef findByClass(string)
            
            findByClass("player")
            findSortByDistance(Device:entity():pos())
            Frame["cursorUser", entity] = find()
            
            #else
            
            local ScreenPos = Device:entity():pos()
            
            local User = owner():pos()
            local Distance = ScreenPos:distance(User)
            
            foreach (I, Player:entity = players()) {
                local TempDistance = ScreenPos:distance(Player:pos())
                if (TempDistance < Distance) {
                    Distance = TempDistance
                    User = Player
                }
            }
            
            Frame["cursorUser", entity] = User
            
            #endif
            
            Frame["cursorTimer", number] = systime() + 1
        }
        
        Frame["cursor", vector2] = Device:egpCursor(Frame["cursorUser", entity])
        Frame["keyUse", number] = Frame["cursorUser", entity]:keyUse()
    }
    else {
        local Cursor = Frame["parent", table]["cursor", vector2]
        if (Cursor != vec2(-1)) {
            Frame["cursor", vector2] = Cursor - Device:egpPos(Frame["id", number])
        }
        else {
            Frame["cursor", vector2] = Cursor
        }
        
        Frame["keyUse", number] = Frame["parent", table]["keyUse", number]
    }
    return Frame["cursor", vector2]
}

function number xkeyUse() {
    return P["xframe", table]["keyUse", number]
}

function number xcanCreate(Count) {
    local Frame = P["xframe", table]
    
    #print("Calling xcanCreate ", Count)
    
    if (!P:exists("xworker") & (Frame["objects", table]:count() - Frame["lastId", number]) >= Count) {
        #print("xcanCreate done ", Count)
        
        return 1
    }
    elseif (!P:exists("xworker")) {
        local XWorker = exec("xworker")
        P["xworker", table] = XWorker
        P["xworkerOut", array] = XWorker["out", array] = array()
        
        XWorker["action", string] = "free"
        XWorker["count", number] = Count
        XWorker["xframe", table] = Frame
        XWorker["device", wirelink] = P["device", wirelink]
        
        #print("Calling xworker ", Count)
    }
    elseif (!P["xworker", table]:isValid()) {
        P:remove("xworker")
        
        if (P["xworkerOut", array]:count() > 0) {
            #print(P["xworkerOut", array])
            P:removeArray("xworkerOut"):clear()
            return 0
        }
        else {
            #print("Xworker done ", Count)
            return 1
        }
    }
    return 0
}

function xregister(Category:string, ProgramName:string) {
    if (S["xmenu", table]:exists(Category)) {
        S["xmenu", table][Category, array]:pushString(ProgramName)
    }
    else {
        S["xmenu", table][Category, array] = array(ProgramName)
    }
}

function xswitch(Objects:table, Id1, Id2) {
    local IId1 = Objects[Id1, table]["id", number]
    local IId2 = Objects[Id2, table]["id", number]
    
    #print(Id1, IId1, "|", Id2, IId2)
    
    local TempObject = Objects[Id1, table]
    Objects[Id1, table] = Objects[Id2, table]
    Objects[Id2, table] = TempObject
    
    Objects[Id1, table]["id", number] = IId1
    Objects[Id2, table]["id", number] = IId2
}

function xparentUpdate(Object:table) {
    P["device", wirelink]:egpParent(Object["id", number], Object["parent", table]["id", number])
}

function xremove(Object:table) {
    local Id = Object["id", number]
    
    if (Object["parentFor", table]:count() > 0) {
        local XWorker = exec("xworker")
        
        XWorker["action", string] = "fullRemove"
        XWorker["object", table] = Object
        XWorker["parentFor", table] = Object["parentFor", table]
        XWorker["device", wirelink] = P["device", wirelink]
    }
    
    Object:clear()
    Object["id", number] = Id
    
    P["device", wirelink]:egpLine(Id, vec2(), vec2())
}
