# Руководство по написанию программ для операционной системы nlix.
# 01.04.2018

Содержание:
1. Создание файла программы.
2. Создание функции программы
3. Работа с памятью программы.
4. Система потоков nlix.
5. Создание программы для терминала.
6. Использование реальных устройств.
7. Перенаправления потоков.
8. Запуск программы с параметрами.

1. Создание файла программы.
Nlix не накладывает ограничений на место хранения исполняемых файлов. Для начала я бы рекоммендовал разместить ваши программы в nlix/other/. После создания файла программы нужно указать ядру, что вы желайте исполнять код вашей новой программы. Это можно сделать следующим образом:

Откройте nlix/nlix.txt и найдите в коде место, куда бы вы хотели разместить файл вашей программы. Для начала можно использовать место, отмеченное как
				
# Place for your first program

В выбранном вами месте нужно разместить код программы. Это будет выглядеть следующим образом:

# Place for your first program
case 55, #include "nlix/other/myprogram" break

Обратите внимание на то, что цифра 55 рядом с оператором case больше, чем у предыдущей описанной программы, но меньше, чем у следующей.

...
case 53, #include "nlix/other/wget" break

# Place for your first program
case 55, #include "nlix/other/myprogram" break

# X
case 59, #include "nlix/x/kbd" break
...

Важно сохранить последовательность всех цифр рядом с оператором case, иначе код вашего или любого другого приложения не загрузится в память системы.

2. Создание функции программы
Ядро операционной системы Nlix для исполнения кода программ выполняет функцию, соответствующую определённой программе. Таблица соответствия программы к функции называется P2F и расшифровывается как "program to function". Поэтому для создания своей программы требуется использовать базовую конструкцию, показанную ниже:

P2F["myprogram", string] = "myprogram"

function myprogram() {
	# Code of your program
}

Если название вашей программы совпадает с названием уже существующей функции, то конструкцию можно видоизменить:

P2F["myprogram", string] = "myprogramFunction"

function myprogramFunction() {
	# Code of your program
}

Таким образом никто не ограничивает вас в имени программы.

3. Работа с памятью программы.
Nlix предоставляет каждой программе память. Она хранится в таблице Ps. Если мы хотим получить доступ к памяти программы, мы можем обратиться к нему с помощью Ps[ProgramId, table]. Для удобства ядро предоставляет возможность обращаться к переменной P, которая содержит память текущей программы. Для примера напишем программу, которое имеет 2 стадии выполнения:

P2F["myprogram", string] = "myprogram"

function myprogram() {
	switch (P["state", number]) {
		case 0,
			print("state " + P["state", number])
			P["state", number] = 1
			break
	
		case 1,
			print("state " + P["state", number])
			end()
			break
	}
}

Программа выведет в чат "state 0", а через тик уже "state 1" и завершит выполнение после комманды end(). Функция end() очищает память программы и указывает ядру, что выполнение кода этой программы стоит прекратить.
Также в таблице P можно указывать любые переменные любых типов кроме "type". Эта переменная зарезервирована для хранения названия программы.

4. Система потоков nlix.
Большинство программ для nlix имеют входной и выходной поток. На момент написания руководства только hotplugd не имеет входных и выходных потоков.
При запуске программы с помощью коммандного интерпретатора sh, коммандный интерпретатор указывает в качестве выходного потока программы драйвер терминала term, а в качестве входного - skbd, название которого расшифровывается как simple keyboard.
skbd позволяет набирать текст на клавиатуре и отправлять во входной поток запущенной программы после нажатия клавиши enter. Таким образом, набрав на клавиатуре "test" и нажав клавишу enter, skbd передаст во входной поток запущенной программы фразу "test".
Драйвер терминала подключен к выходному потоку. Если запущенная программа передаёт в выходной поток фразу "test\n123", то на экране мы видим фразы "test" и на следующей строке "123".

5. Создание программы для терминала.
Для создания программы для терминала удобно использовать libio и его базовые функции, такие как:

number wait()
string in()
out(string)

Функция wait() возвращает 1 когда программа получает какие-либо данные в свой входной поток.
Функция in() позволяет их получить, но только в том случае, если во входном потоке находятся данные типа string.
Функция out(string) позволяет вывести в выходной поток данные типа string.

Таким образом, можно написать простенькую программу, которая будет выводить нам введённый нами текст:

P2F["myprogram", string] = "myprogram"

function myprogram() {
	if (wait()) {
		out("Your input is " + in() + "\n")
		end()
	}
}

6. Использование реальных устройств.
Библиотека libdevices предоставляет нам функцию deviceGet(DeviceType:string) для работы с устройствами, подключаемыми через порты. Для получения устройства удобно использовать конструкцию вида:

P2F["myprogram", string] = "myprogram"

function myprogram() {
	switch (P["state", number]) {
		case 0,
			if (deviceGet("type_of_device")) {
				# Код для инициализации устройства
	
				P["state", number] = 1
			}
			break
	
		case 1,
			# Код для работы с устройством
			break
	}
}

Где type_of_device - это тип устройства, которое вы жалаете получить.
Функция позволяет получить только один девайс такого типа. При закрытии приложения hotplugd сам возвращает устроство в таблицу с устройствами.
После выполнения указанной конструкции, а также внутри скобок условия можно найти полученное устройство в таблице P["device", wirelink].

7. Перенаправления потоков.
Операционная система nlix позволяет нам запустить приложение и считать его вывод. Для этого можно воспользоваться функцией exec(ProgramName:string), не забыв перенаправить вывод программы в удобный нам поток. Для примера перенаправим вывод ls во входной поток нашей программы:

P2F["myprogram", string] = "myprogram"

function myprogram() {
	switch (P["state", number]) {
		case 0,
			local Program = exec("ls")
			P["in", array] = Program["out", array] = array()
		
			P["state", number] = 1
			break
	
		case 1,
			if (wait()) {
				out("Output of \"ls\":\n" + in())
				end()
			}
			break
	}
}

Функция exec(string) возвращает таблицу с памятью программы и указывает ядру приступить к её выполнению. Программа выполнится через несколько тиков, поэтому мы можем подготовить входные потоки к её запуску.
Конструкция

P["in", array] = Program["out", array] = array()

создаёт новый выходной поток для программы "ls", который становится входом для нашей программы. После перехода к следующему состоянию наша программа будет ожидать данные с входного потока и выведет их в выходной поток (если программа запущена в терминале, то в терминал) как только они станут доступны, после чего завершит выполнение.

8. Запуск программы с параметрами.
В прошлом примере мы запустили программу ls и вывели её вывод в терминал. Но ls при отсутствии аргументов выводит только содержимое корневого каталога "/". Чтобы вывести какой-нибудь другой каталог, например, "/devices/", нам потребуется указать это при запуске ls.
Каждую программу можно запустить с аргументами. В коммандном интерпретаторе sh это делается так:

wget http://example.com/ website.html

где "wget" - имя программы, "http://example.com/" - первый аргумент, "website.html" - второй аргумент.
Полученные аргументы хранятся в масссиве P["args", array], где их можно обработать любым удобным вам способом.
Переделаем нашу программу с учётом изменений:

P2F["myprogram", string] = "myprogram"

function myprogram() {
	switch (P["state", number]) {
		case 0,
			local Program = exec("ls")
			P["in", array] = Program["out", array] = array()
			P["arg", array] = array("/devices/")
		
			P["state", number] = 1
			break
	
		case 1,
			if (wait()) {
				out("Output of \"ls\":\n" + in())
				end()
			}
			break
	}
}

Как можно заметить, основные принципы остались те же, разве что теперь мы задаём аргументы с помощью конструкции:

P["arg", array] = array("/devices/")

